Let's go over the solution to the lab. The first thing that we're going to do is look inside main.py and then we'll take a look inside of the template file which will show the user interface. If you look inside main.py, you'll notice that the Python file describes which files are to be shown by the server given the URL that you put into the URL bar. So for example, when you just simply go to the main part of the website, you'll have index.html rendered, and when you go to slash forum, you'll see form.HTML rendered, and these both correspond to templates in the templates folder. This is simply how Flask is set up to make a web app. You'll also notice that there's an API slash predict section, and what this does is it connects the web app to the Cloud ML Engine service. The first thing that it does here is it creates a dictionary called features into which we put all of our features and this is how the application sort of connects with our form that we've made. Then, it calls the get_prediction function. The get_prediction function should look very similar to the other Python code that we've used or it creates an API which accepts our project, our model, and our model version and it passes it a representation of the input data which in this case is the stuff that it harvests from our model and it returns the prediction to be rendered within our webpage. The other thing that you had to do was to look inside the form.html template and within form.html, you'll notice that each of these divs here corresponds to a different part of the layout or the user can then put in a different piece of information into the interface. So for example, here's a slider in order to put in the gestation weeks, and here it is, plurality. Plurality indicates how many babies were born from the mother at that time and yet. You had to turn that into an option box and put in the values for one, two, or three. Once you fixed all the to-dos and you've run the deploy script and selected which region to deploy the app into, you should get something like this. Notice that for every one of the divs in our form.html, we now have some UI elements that allow us to choose the value for all the features that our model expects. So, I'm going to test this out in front of you, you can see what happens. Here is of course the drop-down for plurality, which is one of the to-dos that you had to fix. After choosing values for all of our features and clicking the Predict button, we may have to wait a moment but then the model will return with a prediction for the baby weight. There you have it. In the lab we just completed, we used App Engine to gain access to our model endpoint. But when you actually develop your models, you'll want to have a full fledged API with security and access control policies, third-party access, monetization, and rate-limiting, and quota enforcement. One easy way to do this is with Apigee Edge. Apigee Edge creates a layer of abstraction in between Cloud ML Engine and the applications that want predictions. In this diagram, the FooApp passes an API key to an API proxy. The API proxy forwards request from a proxy endpoint to the target endpoint, which in this case is Cloud ML Engine. Cloud ML Engine is responsible for making predictions. In this case, because the predictions are returned directly, these seem to be online predictions. Cloud ML Engine sits on top of the model which of course is hosted within a Cloud Storage bucket.