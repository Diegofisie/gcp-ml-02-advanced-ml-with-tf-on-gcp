One of the best ways of mitigating training serving skew is to write code that can be used for both development and production. If development production were the same, this would be relatively trivial, but oftentimes, they're different. In this lab, we'll show you how to use polymorphism to abstract the environment dependent aspects of the code while also reusing the parts of the code that need to remain functionally equivalent. Let's pretend that our development environment runs on batches and then our production environment runs on streaming data. This is actually a realistic scenario that speaks to many used cases where the training data are already collected. In development, we might ingest data from CSV files and use our model to write our predictions to other CSV files. In production though, our users are making requests in real-time, and so our input will be streaming. Here, we've captured that with Pub/Sub. For the sake of argument, let's assume that in production, we'd also like to output our predictions to a different location, say, a data warehouse. Critically, though, the input and output steps are different in these two pipelines, the intermediate step where we use the model to make predictions is the same. In order to use polymorphism here, we'll define an abstract class within which our two functions read instances and write predictions, and these functions will be left abstract. We'll then implement those functions into child classes, TextInputOutput, which will be our development pipeline, and PubSubBigQuery, which will be our production pipeline. Because prediction is a step shared by both pipelines, we can implement that within input output, and because we've implemented the step in only one place, we've ensured that our development and production pipelines are the same.