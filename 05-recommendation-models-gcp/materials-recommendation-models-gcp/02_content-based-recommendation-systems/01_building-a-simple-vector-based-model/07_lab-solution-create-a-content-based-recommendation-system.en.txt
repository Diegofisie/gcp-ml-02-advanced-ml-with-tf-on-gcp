So, the goal of this lab is to see how to build a content-based filter using only low-level TensorFlow operations. We're going to follow the technique that we described in the lecture. We'll start by importing the necessary libraries. In this example, we only need Numpy and TensorFlow and we'll print out the version of TensorFlow just to make sure that we're working with 1.8, which we are. So, that's great. In the next cell, we'll give names to our users, names for our movie titles, and our features and we'll set the variables for the number of each of these. Moving on. In this example, we're going to assume that we only have four users, six movies and five features. So, recall that for a content-based filter, it's necessary to hand engineer the features that we're going to use to embed our movies and our users. Here, we're going to use the features of action, sci-fi, comedy, cartoon and drama to create our five dimensional embedding space. In the next cell, we're going to initialize the inputs and define both the user item interaction matrix and the movie feature matrix. The variable users movies holds the user item interaction matrix and each row corresponds to a user and each column corresponds to a movie and the values indicate the ratings of each user gave for each movie. So, for example, looking at the first row, this corresponds to Ryan's ratings for the movies. It looks like Ryan gave a rating of 4 out of 10 for Star Wars, a rating of 6 out of 10 for The Dark Knight and rating a rating of 8 out of 10 for Shrek, and the zeros in the remaining elements of the row indicates that Ryan hasn't seen or hasn't rated the other movies. Ryan has given no ratings for the Incredibles, Blue, or Memento and the same is true for each row after that. The variable movies features here, holds the k-hot encoding of the features for each movie. So, in this matrix, each row represents a movie and each column represents a feature. So, for example, for our first movie, Star Wars, that series of zeros and ones in this row, indicate that Star Wars is encoded as having action, sci-fi, no comedy, no cartoon and some drama. So, since we're doing these computations in TensorFlow, this next block of code is just to take the variables that we set above and store them as TensorFlow constants. Now, we come to our first to-do. The goal here is to create the users movies features Tensor that we discussed in the lecture. So, this is going to be made by stacking together the weighted features matrices for each user. What we'll want to do is, compute the weighted feature matrix for each user can store all those as a list and then we can stack them together using a tf.stack operation. So, let's do that now. So, in code, we can create a list of this product for each user using a list comprehension. So, I'll start with list comprehension in this way. I will be multiplying each row of the users' movies matrix to the values in the movies features matrix. So, I'll take the user's movies matrix. I want to take the transpose of that. I can do that using tf.transpose here. To take one row, I'll slice this out. After taking the transpose, I'll slice it out by taking all the rows and just the ith column and then I'll multiply that by the movies features matrix and I want to do this for every user. So, to create in my list comprehension, I'll do this for all the i's in the range from 0 to the number of users that I have. So, in order for this broadcast multiplication to work, we also need to expand the dimensions of the users movies tensor in the first axis. So, this computation itself wouldn't work on its own. So, what we need to do is use a tf.expand dimensions of our transpose of the users movies matrix and we'll specify the axis to be equal to one. So, now what this will do, is it will create a list which is going to be the weighted feature matrix for every user in our database. Next, what we'll do, is we'll stack together these weighted feature matrices to create our total user make movies features tensor. So, in Tensorflow, the way that would look is, we can just do a tf.stack on the weighted feature matrices that we computed just above. The last step is to normalize this user's movies features tensor against the movies dimension. So that the components all sum to one. This is done by summing across the movies dimension, in that tensor we created above and then normalizing with the total values. So, those two values are computed here; users_movies_feats_sums, sums against the movies dimension. So, to do that we're using a tf.reduce_sum. Here we're specifying the axis to be equal to one because that's the axis for our movies and our users movies features totals then we'll do another reduce_sum which is then going to sum for each user the sum of all the feature values. So, next what we want to do is, normalize this tensor for each user and we can do that using a list comprehension. So, I'll set up my list, we'll take the users_movies_feats_sums for each user and we'll divide by the users_movies_feats_totals for each user and we'll do this for every i in the range from 0 to the number of our users. This is going to create a list that has the user feature vector for every user in our database and so, the last thing we're going to do is stack these tensors together to create a single matrix for all of our user feature vectors. So, like before, we'll use a tf.stack and we'll set our axis to be equal to 0. So, the resulting users features matrix that we just created is a collection of all the user feature vectors for each of the four users that we have. Given this, we can look back and interpret the feature relevance for each user and we're gonna do this the following upper function, so you can see that here. So, let's read through what this function does. So, this function find_users_top_feats takes as input a user Index and what it returns, are the top features for that given user. So, to do that, we're using this top k function in TensorFlow and what we'll pass are the users features that we created above for that user and we're going to ask it to return the top five features for each user. The last element of this function then, is to use tf.gather in D and what this does is it takes a list of our features and it just evaluates the top indices for that given user. If we actually want to evaluate what these variables are equal to, since we're working in TensorFlow, we need to create a TensorFlow session. So, that's what we do in the following cell. So, we create a TensorFlow session here and we initialize our global variables. We're going to create this empty dictionary called users_topfeats and what we'll do in the following for loop, is just propagate that dictionary where each key will correspond to a user and each value of that key will correspond to that user's top features. So, you can see that's what's happening here. The top features it will evaluate in the session, define users_topfeats for that single user. To propagate the dictionary, we're going to set the key to be equal to that user and the value will be the list that we return that we're calling top features. So, this next cell we can look and see what our users top features look like. So, looking at the first example, we see that for Chris, the most important features for him would be action, then sci-fi, then drama, then comedies, and then cartoons, and the same for all the other users in our database. So, in this last section, what we're going to do is, we're gonna use that user's features tensor to determine our movie recommendations for each of our users. To do this, we'll need to compute the similarity measure between each user and each movie. We'll use a dot product as our similarity measure. Since we want to compute the dot product between a given user feature vector and every movie in our database, we can use a map function. So, that's where we come to this to do here. Actually gives us a hint telling us we can use the tf.map function. What it does is, it applies some given lambda function to a list of Tensors and since we're taking the dot product as our similarity measure, the operation we want to use is a tf.tenserdot. So, to fill this out, what we'll do is, we'll take tf.map function, we'll set up our lambda function. What this will do is, it'll compute the dot products. So, tf.tenserdot between our users features tensor for each user. Setup here X because it will be taking a dot product of that vector with the movie features vector. We'll set the axes equal to one since we're taking the dot product using tenserdot. Then we specify what we want to iterate this lambda function over and we're multiplying through the movies features vector. So, it's that up here. This will compute the user ratings for a single user so as before, I'm going to wrap this in a list comprehension. I want to do this again for all the i's in the range from 0 to the number of users that we have. This last part of the cell just says, once you have that list of all the users ratings, stack them together to get a single tensor called all_users_ratings. So, moving on. As we mentioned in the lecture, to make movie recommendations, we don't want to bother with movies that the user has already seen. So, we're going to create a mask so we can ignore the previously rated movies. We can do that using tf.where. So, just to remind you, the way tf works is by specifying a Boolean condition. When the condition is true, we take the first value and if the condition is false, we take the second. So, here's our Boolean condition, this tf.equal. We're going to see where is our user's movies tensor equal to 0 and when it is equal to 0, we're going to use the all users ratings and when it's not equal to 0, we're going to set it to be equal to minus infinity just so we can completely ignore it. Define the top movie recommendations for each user, we'll use a similar helper function to the one we saw above. The function here, find user top movies, takes two inputs. It takes the user index and the number of movies to recommend. And it does two things. So first, it determines the movies index. So, these are the indices of the top movies for a single user. So, we're using the top k function as before. As input, we are giving it the all users ratings new matrix that we created above which is just our user ratings for all of our users but masking out the movies the user has already rated and we're passing the number of movies to recommend. This could change for certain users because users have seen different numbers of movies. At the end, we just return the movies for each given user. Again, to do that, we'll use this gather in D operation, we pass in our movies list and we say evaluated at the indices that we found above. So, as before, in order to evaluate these values, we need to create a TensorFlow session. We'll initialize our global values using tf.global_variables_initializer. Then create an empty dictionary called user_topmovies. What we'll do in this next for loop, is to propagate that dictionary, again, using the users as keys and then now the values will be a list of their top movies. So, for each user, we want to figure out how many movies to recommend and to do that, we'll create this variable called number to recommend. It just going to be done by taking a reduce sum on the user's movies matrix and figuring out how many times there are zeros for each user. The for loop will then iterate through each of our users and it will collect the top movies using our find user top movies function above. Then add to our dictionary, the key which is the user and the value which is the list of the movies for that user. We can then examine what this dictionary looks like and see what the movie recommendations would be for any one of our users. So, for example, for Danielle, we see that for her we'd likely want to recommend The Incredibles first, Star Wars second, and The Dark Knight third