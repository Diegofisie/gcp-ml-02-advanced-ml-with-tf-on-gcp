Congratulations. You've built your first RNN and used it to predict the amplitude of a sprinkler. Now that you've got the basic implementation down, let's talk about some improvements we can make to our RNN model. Up until now we've been using a single cell in our RNN, but it doesn't have to be that way. Just like we increased the capacity of a DNN by adding more layers, we can increase the capacity of an RNN by adding more cells. Here, we have a two-layer RNN. The first layer is the same as before, and the second layer takes as its input the output from the first layer. Sound familiar? It acts the same exact way as a DNN except with the state vector attached. How does this look in code? Instead of passing a single cell to a tf.nn.dynami_rnn as before, we pass it a multi RNN cell object. The multi RNN cell object is instantiated with a list of cells. Simple as that. Be careful though, because the state object returned by the dynamic RNN is no longer just a single vector but a list of vectors corresponding to the final state of each of the cells. In this case, three. Normally, we'll take just the last state vector and the list to pass on to our DNN because it already takes into account these days from the previous layers.