Let's take a look at the code. At the top of the IPython Notebook, you see our login credentials for our GCP account. Below that, you'll see us calling the model locally from the command line. In order that this code works, we need to have successfully added code in all the to-do sections in our model.py, so that's what we'll look next. To find our model.py, you need to navigate to the flowersmodel directory inside your Lab folder. In this case, I'm looking at the solution. In our model.py, there are basically two places where we need to make changes; inside our read_and_preprocess function, and inside our input function. In our read_and_preprocess function, we need to introduce the image decode jpeg function, which takes the image bytes which we read from disk and converts them into an image representation. This function requires that we parse in a channel's parameter. After that, because image decode jpeg leaves the image as a range from 0-255, we need to convert the image D type to a float representation. We do this by passing in the tf.float32 type. The next part of the code branches on whether or not we're intending to augment or not. If we're augmenting, the next thing that we're going to do is resize to a size that is bigger than our actual image, in order that when we randomly crop later, it will actually be cropped to the right size. After we resize though, because we've expanded dimensions in order to use the resize function, we squeeze the image to remove the unnecessary dimension. Then finally, we call random crop parsing in height, width and numb channels. This will randomly crop a section of the image, but the resulting crop will be the appropriate size for our model. Then we call another bunch of random functions including random flip left right, random brightness and random contrast. Note again the fact that we parse in some numerical parameters to random brightness and random contrast, and these are the things that you'll understand the best values for by understanding your domain. If augmented set to false, we can simply call resize bi-linear and resize it to the appropriate size of the image. At the end of this, the final thing we need to do is to subtract 0.5 from all the values in our image and then multiply by two, and this maps the range of the values inside our image sensor to the range negative one to one. Finally, we package our image up inside the dictionary. The next thing that we need to do is look at our input function. In our input function, we make one principal modification. What we need to do is condition upon our augment Boolean variable. Any event that augment is true, we're going to map the read_and_preprocess with augment function. In the event that it's false, we're simply going to map the read_and_preprocess function. The only difference between these two functions is that whereas read_and_preprocess with augment simply calls read_and_preprocess with the augment variable set to true, otherwise, the default value for augment is false. That's it.